import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { DataSource, Repository } from 'typeorm';
import { Product } from '../entities/product.entity';
import { Stock } from '../entities/stock.entity';
import { Warehouse } from '../entities/warehouse.entity';
import { PurchaseOrder } from '../entities/purchase-order.entity';
import { PurchaseOrderItem } from '../entities/purchase-order-item.entity';
import { CreateProductDto } from '../dto/create-product.dto';
import { UpdateStockDto } from '../dto/update-stock.dto';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class InventoryService {
  constructor(
    @InjectRepository(Product)
    private productRepository: Repository<Product>,
    @InjectRepository(Stock)
    private stockRepository: Repository<Stock>,
    @InjectRepository(Warehouse)
    private warehouseRepository: Repository<Warehouse>,
    @InjectRepository(PurchaseOrder)
    private purchaseOrderRepository: Repository<PurchaseOrder>,
    @InjectRepository(PurchaseOrderItem)
    private purchaseOrderItemRepository: Repository<PurchaseOrderItem>,
    private dataSource: DataSource,
    private configService: ConfigService,
  ) {}

  async createProduct(createProductDto: CreateProductDto): Promise<Product> {
    const product = this.productRepository.create(createProductDto);
    return await this.productRepository.save(product);
  }

  async getAllProducts(): Promise<Product[]> {
    return await this.productRepository.find({
      where: { isActive: true },
      relations: ['stocks'],
    });
  }

  async getProductById(id: string): Promise<Product> {
    const product = await this.productRepository.findOne({
      where: { id },
      relations: ['stocks', 'stocks.warehouse'],
    });
    if (!product) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }
    return product;
  }

  async updateStock(updateStockDto: UpdateStockDto): Promise<Stock> {
    const { productId, warehouseId, quantity } = updateStockDto;

    // Verify product and warehouse exist
    const product = await this.productRepository.findOne({
      where: { id: productId },
    });
    if (!product) {
      throw new NotFoundException(`Product with ID ${productId} not found`);
    }

    const warehouse = await this.warehouseRepository.findOne({
      where: { id: warehouseId },
    });
    if (!warehouse) {
      throw new NotFoundException(`Warehouse with ID ${warehouseId} not found`);
    }

    // Use transaction for stock update
    return await this.dataSource.transaction(async (manager) => {
      let stock = await manager.findOne(Stock, {
        where: { productId, warehouseId },
      });

      if (!stock) {
        stock = manager.create(Stock, {
          productId,
          warehouseId,
          quantity: 0,
          reservedQuantity: 0,
          availableQuantity: 0,
        });
      }

      const oldQuantity = stock.quantity;
      stock.quantity = quantity;
      stock.availableQuantity = stock.quantity - stock.reservedQuantity;

      const savedStock = await manager.save(Stock, stock);

      // Check if stock is low and generate purchase order
      if (
        savedStock.availableQuantity <= product.lowStockThreshold &&
        product.lowStockThreshold > 0
      ) {
        await this.checkAndGeneratePurchaseOrder(
          product,
          warehouse,
          savedStock,
          manager,
        );
      }

      return savedStock;
    });
  }

  private async checkAndGeneratePurchaseOrder(
    product: Product,
    warehouse: Warehouse,
    stock: Stock,
    manager: any,
  ): Promise<void> {
    // Check if there's already a pending purchase order for this product
    const existingOrder = await manager
      .createQueryBuilder(PurchaseOrder, 'po')
      .innerJoin('po.items', 'item')
      .where('po.warehouseId = :warehouseId', { warehouseId: warehouse.id })
      .andWhere('item.productId = :productId', { productId: product.id })
      .andWhere('po.status IN (:...statuses)', {
        statuses: ['pending', 'approved', 'ordered'],
      })
      .getOne();

    if (existingOrder) {
      return; // Already has pending order
    }

    // Calculate required quantity (threshold * 2 to avoid frequent orders)
    const requiredQuantity = product.lowStockThreshold * 2;

    // Generate purchase order
    const orderNumber = `PO-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const purchaseOrder = manager.create(PurchaseOrder, {
      orderNumber,
      warehouseId: warehouse.id,
      status: 'pending',
      isAutoGenerated: true,
      totalAmount: 0,
    });

    const savedOrder = await manager.save(PurchaseOrder, purchaseOrder);

    const orderItem = manager.create(PurchaseOrderItem, {
      purchaseOrderId: savedOrder.id,
      productId: product.id,
      quantity: requiredQuantity,
      unitPrice: product.unitPrice,
      totalPrice: requiredQuantity * product.unitPrice,
    });

    await manager.save(PurchaseOrderItem, orderItem);

    // Update total amount
    savedOrder.totalAmount = orderItem.totalPrice;
    await manager.save(PurchaseOrder, savedOrder);
  }

  async getStockByWarehouse(warehouseId: string): Promise<Stock[]> {
    const warehouse = await this.warehouseRepository.findOne({
      where: { id: warehouseId },
    });
    if (!warehouse) {
      throw new NotFoundException(`Warehouse with ID ${warehouseId} not found`);
    }

    return await this.stockRepository.find({
      where: { warehouseId },
      relations: ['product'],
      order: { product: { name: 'ASC' } },
    });
  }

  async getStockByProduct(productId: string): Promise<Stock[]> {
    const product = await this.productRepository.findOne({
      where: { id: productId },
    });
    if (!product) {
      throw new NotFoundException(`Product with ID ${productId} not found`);
    }

    return await this.stockRepository.find({
      where: { productId },
      relations: ['warehouse'],
    });
  }

  async reserveStock(
    productId: string,
    warehouseId: string,
    quantity: number,
  ): Promise<Stock> {
    return await this.dataSource.transaction(async (manager) => {
      const stock = await manager.findOne(Stock, {
        where: { productId, warehouseId },
      });

      if (!stock) {
        throw new NotFoundException(
          `Stock not found for product ${productId} in warehouse ${warehouseId}`,
        );
      }

      if (stock.availableQuantity < quantity) {
        throw new BadRequestException(
          `Insufficient stock. Available: ${stock.availableQuantity}, Requested: ${quantity}`,
        );
      }

      stock.reservedQuantity += quantity;
      stock.availableQuantity = stock.quantity - stock.reservedQuantity;

      return await manager.save(Stock, stock);
    });
  }

  async releaseReservedStock(
    productId: string,
    warehouseId: string,
    quantity: number,
  ): Promise<Stock> {
    return await this.dataSource.transaction(async (manager) => {
      const stock = await manager.findOne(Stock, {
        where: { productId, warehouseId },
      });

      if (!stock) {
        throw new NotFoundException(
          `Stock not found for product ${productId} in warehouse ${warehouseId}`,
        );
      }

      if (stock.reservedQuantity < quantity) {
        throw new BadRequestException(
          `Cannot release more than reserved. Reserved: ${stock.reservedQuantity}, Requested: ${quantity}`,
        );
      }

      stock.reservedQuantity -= quantity;
      stock.availableQuantity = stock.quantity - stock.reservedQuantity;

      return await manager.save(Stock, stock);
    });
  }

  async consumeStock(
    productId: string,
    warehouseId: string,
    quantity: number,
  ): Promise<Stock> {
    return await this.dataSource.transaction(async (manager) => {
      const stock = await manager.findOne(Stock, {
        where: { productId, warehouseId },
      });

      if (!stock) {
        throw new NotFoundException(
          `Stock not found for product ${productId} in warehouse ${warehouseId}`,
        );
      }

      if (stock.reservedQuantity < quantity) {
        throw new BadRequestException(
          `Cannot consume unreserved stock. Reserved: ${stock.reservedQuantity}, Requested: ${quantity}`,
        );
      }

      stock.quantity -= quantity;
      stock.reservedQuantity -= quantity;
      stock.availableQuantity = stock.quantity - stock.reservedQuantity;

      const savedStock = await manager.save(Stock, stock);

      // Check low stock after consumption
      const product = await manager.findOne(Product, {
        where: { id: productId },
      });
      if (
        savedStock.availableQuantity <= product.lowStockThreshold &&
        product.lowStockThreshold > 0
      ) {
        const warehouse = await manager.findOne(Warehouse, {
          where: { id: warehouseId },
        });
        await this.checkAndGeneratePurchaseOrder(
          product,
          warehouse,
          savedStock,
          manager,
        );
      }

      return savedStock;
    });
  }

  async getLowStockProducts(warehouseId?: string): Promise<Stock[]> {
    const query = this.stockRepository
      .createQueryBuilder('stock')
      .innerJoinAndSelect('stock.product', 'product')
      .innerJoinAndSelect('stock.warehouse', 'warehouse')
      .where('stock.availableQuantity <= product.lowStockThreshold')
      .andWhere('product.lowStockThreshold > 0')
      .andWhere('product.isActive = :isActive', { isActive: true });

    if (warehouseId) {
      query.andWhere('stock.warehouseId = :warehouseId', { warehouseId });
    }

    return await query.getMany();
  }

  async getPurchaseOrders(
    warehouseId?: string,
    status?: string,
  ): Promise<PurchaseOrder[]> {
    const query = this.purchaseOrderRepository
      .createQueryBuilder('order')
      .leftJoinAndSelect('order.items', 'items')
      .leftJoinAndSelect('items.product', 'product');

    if (warehouseId) {
      query.where('order.warehouseId = :warehouseId', { warehouseId });
    }

    if (status) {
      query.andWhere('order.status = :status', { status });
    }

    return await query.orderBy('order.createdAt', 'DESC').getMany();
  }
}
